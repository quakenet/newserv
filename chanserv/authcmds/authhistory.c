/* Automatically generated by refactor.pl.
 *
 *
 * CMDNAME: authhistory
 * CMDLEVEL: QCMD_AUTHED
 * CMDARGS: 2
 * CMDDESC: View auth history for an account.
 * CMDFUNC: csa_doauthhistory
 * CMDPROTO: int csa_doauthhistory(void *source, int cargc, char **cargv);
 * CMDHELP: Usage: AUTHHISTORY
 * CMDHELP: Displays details of the last 10 logins with your account.  Details include
 * CMDHELP: hostmask, login time, disconnect time and reason.
 */

#include "../chanserv.h"
#include "../authlib.h"
#include "../../lib/irc_string.h"
#include "../../dbapi/dbapi.h"

#include <stdio.h>
#include <string.h>

struct authhistoryinfo {
  unsigned int numeric;
  unsigned int userID;
};

void csdb_doauthhistory_real(DBConn *dbconn, void *arg) {
  struct authhistoryinfo *ahi=(struct authhistoryinfo*)arg;
  nick *np=getnickbynumeric(ahi->numeric);
  reguser *rup;
  char *ahnick, *ahuser, *ahhost;
  time_t ahauthtime, ahdisconnecttime;
  DBResult *pgres;
  int count=0;
  char tbuf1[TIMELEN], tbuf2[TIMELEN], uhbuf[NICKLEN+HOSTLEN+USERLEN+5];

  if(!dbconn) {
    free(ahi);
    return;
  }

  pgres=dbgetresult(dbconn);

  if (!dbquerysuccessful(pgres)) {
    Error("chanserv", ERR_ERROR, "Error loading auth history data.");
    free(ahi);
    return;
  }

  if (dbnumfields(pgres) != 7) {
    Error("chanserv", ERR_ERROR, "Auth history data format error.");
    dbclear(pgres);
    free(ahi);
    return;
  }

  if (!np) {
    dbclear(pgres);
    free(ahi);
    return;
  }

  if (!(rup=getreguserfromnick(np))) {
    dbclear(pgres);
    free(ahi);
    return;
  }
  chanservstdmessage(np, QM_AUTHHISTORYHEADER); /* @TIMELEN */
  while(dbfetchrow(pgres)) {
    if (!UHasHelperPriv(rup) && (strtoul(dbgetvalue(pgres, 0), NULL, 10) != rup->ID)) {
      dbclear(pgres);
      free(ahi);
      return;
    }
    ahnick=dbgetvalue(pgres, 1);
    ahuser=dbgetvalue(pgres, 2);
    ahhost=dbgetvalue(pgres, 3);
    ahauthtime=strtoul(dbgetvalue(pgres, 4), NULL, 10);
    ahdisconnecttime=strtoul(dbgetvalue(pgres, 5), NULL, 10);

    q9strftime(tbuf1, sizeof(tbuf1), ahauthtime);
    if (ahdisconnecttime)
      q9strftime(tbuf2, sizeof(tbuf2), ahdisconnecttime);

    snprintf(uhbuf,sizeof(uhbuf),"%s!%s@%s", ahnick, ahuser, ahhost);
    chanservsendmessage(np, "#%-2d %-50s %-19s %-19s %s", ++count, uhbuf, tbuf1, ahdisconnecttime?tbuf2:"never", dbgetvalue(pgres,6)); /* @TIMELEN */
  }
  chanservstdmessage(np, QM_ENDOFLIST);

  dbclear(pgres);
  free(ahi);
}

void csdb_retreiveauthhistory(nick *np, reguser *rup, int limit) {
  struct authhistoryinfo *ahi;
  char limitstr[30];

  if (limit) {
    sprintf(limitstr, " limit %d",limit);
  } else {
    limitstr[0]='\0';
  }

  ahi=(struct authhistoryinfo *)malloc(sizeof(struct authhistoryinfo));
  ahi->numeric=np->numeric;
  ahi->userID=rup->ID;
  q9a_asyncquery(csdb_doauthhistory_real, (void *)ahi,
    "SELECT userID, nick, username, host, authtime, disconnecttime, quitreason from chanserv.authhistory where "
    "userID=%u order by authtime desc%s", rup->ID, limitstr);
}

int csa_doauthhistory(void *source, int cargc, char **cargv) {
  reguser *rup, *trup;
  nick *sender=source;
  unsigned int arg=0;
  unsigned int limit=10;
  
  if (!(rup=getreguserfromnick(sender)))
    return CMD_ERROR;

  if (cargc) {
    if (!ircd_strcmp(cargv[0], "-a")) {
      if (UHasOperPriv(rup))
        limit=0;
      
      arg++;
    }
  }

  if (cargc > arg) {
    if (!(trup=findreguser(sender, cargv[arg])))
      return CMD_ERROR;

    /* don't allow non-opers to view oper auth history, but allow helpers to view non-oper history */
    if ((trup != rup) && ((UHasOperPriv(trup) && !UHasOperPriv(rup)) || !UHasHelperPriv(rup))) {
      chanservstdmessage(sender, QM_NOACCESSONUSER, "authhistory", cargv[arg]);
      return CMD_ERROR;
    }
  } else {
    trup=rup;
  }
  
  csdb_retreiveauthhistory(sender, trup, limit);

  return CMD_OK;
}
