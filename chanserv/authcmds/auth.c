/* Automatically generated by refactor.pl.
 *
 *
 * CMDNAME: auth
 * CMDALIASES: login ircdauth
 * CMDLEVEL: QCMD_SECURE | QCMD_NOTAUTHED
 * CMDARGS: 2
 * CMDDESC: Authenticates you on the bot.
 * CMDFUNC: csa_doauth
 * CMDPROTO: int csa_doauth(void *source, int cargc, char **cargv);
 * CMDHELP: Usage: @UCOMMAND@ <username> <password>
 * CMDHELP: Authenticates you on the bot, where:
 * CMDHELP: username - your username
 * CMDHELP: password - your password
 * CMDHELP: If you do not have a username and password, see HELLO.
 * CMDHELP: Note: due to the sensitive nature of this command, you must send the message
 * CMDHELP: to Q@CServe.quakenet.org when using it.
 * CMDHELP: Note: the preferred way to authenticate is to use the /AUTH command.
 */

#include "../chanserv.h"
#include "../authlib.h"
#include "../../lib/irc_string.h"
#include <stdio.h>
#include <string.h>

int csa_completeauth(nick *sender, reguser *rup, char *authtype);

int csa_auth(void *source, int cargc, char **cargv, CRAlgorithm alg) {
  reguser *rup;
  activeuser *aup;
  nick *sender=source;
  int challenge=0;
  char *authtype = "AUTH";

  if (alg) {
    challenge=1;
    authtype = "CHALLENGEAUTH";
  } else if (cargc<2) {
    chanservstdmessage(sender, QM_NOTENOUGHPARAMS, "auth");
    return CMD_ERROR;
  }
  
  if (!(aup = getactiveuserfromnick(sender)))
    return CMD_ERROR;
  
  aup->authattempts++;
  if (aup->authattempts > MAXAUTHATTEMPT) {
/*
    if ((aup->authattempts % 100) == 0)
      chanservwallmessage("Warning: User %s!%s@%s attempted to auth %d times. Last attempt: %s %s %s",
        sender->nick, sender->ident, sender->host->name->content, aup->authattempts, authtype, cargv[0], cargv[1]);
*/

    chanservstdmessage(sender, QM_TOOMANYAUTHATTEMPTS);
    cs_log(sender,"%s FAIL too many auth attempts (last attempt: %s %s %s)", authtype, authtype, cargv[0], cargv[1]); 
    return CMD_ERROR;
  }

  if (!(rup=findreguserbynick(cargv[0]))) {
    chanservstdmessage(sender, QM_AUTHFAIL);
    cs_log(sender,"%s FAIL bad username %s",authtype,cargv[0]); 
    return CMD_ERROR;
  }

  if (!challenge) {
    if (!checkpassword(rup, cargv[1])) {
      chanservstdmessage(sender, QM_AUTHFAIL);
      cs_log(sender,"%s FAIL username %s bad password %s",authtype,rup->username,cargv[1]);
      return CMD_ERROR;
    }
  } else {
    if (!checkresponse(rup, aup->entropy, cargv[1], alg)) {
      chanservstdmessage(sender, QM_AUTHFAIL);
      cs_log(sender,"%s FAIL username %s bad response",authtype,rup->username);
      return CMD_ERROR;
    }
  }

  return csa_completeauth(sender, rup, authtype);
}

int csa_doauth(void *source, int cargc, char **cargv) {
  return csa_auth(source, cargc, cargv, NULL);
}

int csa_completeauth(nick *sender, reguser *rup, char *authtype) {
  void *args[2];
  time_t oldlastauth;

  oldlastauth=rup->lastauth;

  if(!csa_completeauth2(rup, sender->nick, sender->ident, sender->host->name->content, authtype, chanservstdmessage, sender))
    return CMD_ERROR;

  localusersetaccount(sender, rup->username, rup->ID, cs_accountflagmap(rup), rup->lastauth);

  chanservstdmessage(sender, QM_AUTHOK, rup->username);

  args[0]=sender;
  args[1]=(void *)oldlastauth;
  /* note: not triggered for REMOTEAUTH */
  triggerhook(HOOK_CHANSERV_AUTH, args);

  return CMD_OK;
}
