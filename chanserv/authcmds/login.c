/* Automatically generated by refactor.pl.
 *
 *
 * CMDNAME: login
 * CMDLEVEL: QCMD_SECURE | QCMD_NOTAUTHED
 * CMDARGS: 2
 * CMDDESC: Authenticates you on the bot.
 * CMDFUNC: csa_doauth
 * CMDPROTO: int csa_doauth(void *source, int cargc, char **cargv);
 */

#include "../chanserv.h"
#include "../authlib.h"
#include "../../lib/irc_string.h"
#include <stdio.h>
#include <string.h>

int csa_doauth(void *source, int cargc, char **cargv) {
  reguser *rup;
  activeuser* aup;
  nick *sender=source;
  nicklist *nl = NULL;
  char userhost[USERLEN+HOSTLEN+2];
  int ucount=0;

  if (cargc<2) {
    chanservstdmessage(sender, QM_NOTENOUGHPARAMS, "auth");
    return CMD_ERROR;
  }
  
  if (!(aup = getactiveuserfromnick(sender)))
    return CMD_ERROR;
  
  aup->authattempts++;
  if (aup->authattempts > MAXAUTHATTEMPT) {
    if ((aup->authattempts % 100) == 0)
      chanservwallmessage("Warning: User %s!%s@%s attempted to auth %d times. Last attempt: AUTH %s %s", 
        nl->np->nick, nl->np->ident, nl->np->host->name->content, cargv[0], cargv[1]);
    chanservstdmessage(sender, QM_AUTHFAIL);
    cs_log(sender,"AUTH FAIL too many auth attempts (last attempt: AUTH %s %s)",cargv[0], cargv[1]); 
    return CMD_ERROR;
  }

  if (!(rup=findreguserbynick(cargv[0]))) {
    chanservstdmessage(sender, QM_AUTHFAIL);
    cs_log(sender,"AUTH FAIL bad username %s",cargv[0]); 
    return CMD_ERROR;
  }

  if (!checkpassword(rup, cargv[1])) {
    chanservstdmessage(sender, QM_AUTHFAIL);
    cs_log(sender,"AUTH FAIL username %s bad password %s",rup->username,cargv[1]);
    return CMD_ERROR;
  }

  rup->lastauth=time(NULL);
  sprintf(userhost,"%s@%s",sender->ident,sender->host->name->content);
  if (rup->lastuserhost)
    freesstring(rup->lastuserhost);
  rup->lastuserhost=getsstring(userhost,USERLEN+HOSTLEN+1);
  
  if (UHasSuspension(rup) && rup->suspendexp && (time(0) >= rup->suspendexp)) {
    /* suspension has expired, remove it */
    rup->flags&=(~(QUFLAG_SUSPENDED|QUFLAG_GLINE|QUFLAG_DELAYEDGLINE));
    rup->suspendby=0;
    rup->suspendexp=0;
    freesstring(rup->suspendreason);
    rup->suspendreason=0;
  }
  
  if (UIsNeedAuth(rup))
    rup->flags&=~(QUFLAG_NEEDAUTH);
  csdb_updateuser(rup);
  
  if (UIsDelayedGline(rup)) {
    /* delayed-gline - schedule the user's squelching */
    deleteschedule(NULL, &chanservdgline, (void*)rup); /* icky, but necessary unless we stick more stuff in reguser structure */
    scheduleoneshot(time(NULL)+rand()%900, &chanservdgline, (void*)rup);
  }
  else if (UIsGline(rup)) {
    /* instant-gline - lets be lazy and set a schedule expiring now :) */
    deleteschedule(NULL, &chanservdgline, (void*)rup); /* icky, but necessary unless we stick more stuff in reguser structure */
    scheduleoneshot(time(NULL), &chanservdgline, (void*)rup);
  }
  else if (UIsSuspended(rup)) {
    /* plain suspend */
    chanservstdmessage(sender, QM_AUTHSUSPENDED);
    if(rup->suspendreason)
      chanservstdmessage(sender, QM_REASON, rup->suspendreason->content);
    if (rup->suspendexp) {
      struct tm* tmp;
      char buf[200];
      
      tmp=gmtime(&(rup->suspendexp));
      strftime(buf, 15, "%d/%m/%y %H:%M", tmp);
      chanservstdmessage(sender, QM_EXPIRES, buf);
    }
    return CMD_ERROR;
  }
  
  if (!UHasHelperPriv(rup) && !UIsNoAuthLimit(rup)) {
    for (nl=rup->nicks; nl; nl=nl->next)
      ucount++;
    
    if (ucount >= MAXAUTHCOUNT) {
      chanservstdmessage(sender, QM_TOOMANYAUTHS);
      return CMD_ERROR;
    }
  }
  
  chanservstdmessage(sender, QM_AUTHOK, rup->username);
  cs_log(sender,"AUTH OK username %s", rup->username);
  localusersetaccount(sender, rup->username);
  csdb_authhistory_auth(sender, rup);

  return CMD_OK;
}
