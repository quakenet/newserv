/* Automatically generated by refactor.pl.
 *
 *
 * CMDNAME: op
 * CMDLEVEL: QCMD_AUTHED
 * CMDARGS: 20
 * CMDDESC: Ops you or other users on channel(s).
 * CMDFUNC: csc_doop
 * CMDPROTO: int csc_doop(void *source, int cargc, char **cargv);
 * CMDHELP: Usage: OP [<channel> [<user1> [<user2> [...]]]
 * CMDHELP: Ops you on one or more channels, or ops other named users on a given channel.
 * CMDHELP: This command cannot be used to op users who are otherwise prevented from getting
 * CMDHELP: ops, e.g. via the +d chanlev flag (see CHANLEV) or bitch mode (see CHANFLAGS).
 * CMDHELP: Where:
 * CMDHELP: channel - channel to use.  If no channel is specified, you will be given ops on
 * CMDHELP:           every channel where you have appropriate access and are not already
 * CMDHELP:           opped.
 * CMDHELP: user<n> - user(s) to op instead of yourself.  Each user must be specified as the
 * CMDHELP:           current nickname of a user on the named channel.
 * CMDHELP: OP requires operator access (+o) on the named channel.  If this command is used
 * CMDHELP: to op other users, a notice will be sent to other channel operators on the 
 * CMDHELP: channel identifying you, unless you have master (+m) access.
 */

#include "../chanserv.h"
#include "../../nick/nick.h"
#include "../../lib/flags.h"
#include "../../lib/irc_string.h"
#include "../../channel/channel.h"
#include "../../parser/parser.h"
#include "../../irc/irc.h"
#include "../../localuser/localuserchannel.h"
#include <string.h>
#include <stdio.h>

int csc_doop(void *source, int cargc, char **cargv) {
  nick *sender=source, *np;
  reguser *rup=getreguserfromnick(sender);
  chanindex *cip;
  regchan *rcp=NULL;
  regchanuser *rcup;
  channel **ca;
  unsigned long *lp;
  int i;
  modechanges changes;
  int donotice=0;
  char buf[512], bufpos=0;

  if (!rup)
    return CMD_ERROR;
  
  if (cargc==0) {
    /* No args: "op me on every channel you can */
    ca=sender->channels->content;
    for (i=0;i<sender->channels->cursi;i++) {
      if ((rcp=ca[i]->index->exts[chanservext]) && !CIsSuspended(rcp)) {
	/* It's a Q channel */
	if (!(*(getnumerichandlefromchanhash(ca[i]->users, sender->numeric)) & 
	      CUMODE_OP)) {
	  /* They're not opped */
	  if ((rcup=findreguseronchannel(rcp, rup)) && CUHasOpPriv(rcup) && 
	      !CUIsDeny(rcup)) {
	    /* And they have op priv on the chan: op them */
	    localsetmodeinit(&changes, ca[i], chanservnick);
	    localdosetmode_nick(&changes, sender, MC_OP);
	    localsetmodeflush(&changes,1);
	  }
	}
      }
    }
    
    chanservstdmessage(sender, QM_DONE);
    return CMD_OK;
  }

  /* If there is at least one arg, the first is a channel */

  if (!(cip=cs_checkaccess(sender, cargv[0], CA_OPPRIV, NULL, "op", 0, 0)))
    return CMD_ERROR;

  rcp=cip->exts[chanservext];

  if (cargc==1) {
    /* Only one arg: "op me" */
    if (!cs_checkaccess(sender, NULL, CA_OPPRIV | CA_DEOPPED, cip, "op", 0, 0))
      return CMD_ERROR;
    
    localsetmodeinit(&changes, cip->channel, chanservnick);
    localdosetmode_nick(&changes, sender, MC_OP);
    localsetmodeflush(&changes,1);

    chanservstdmessage(sender, QM_DONE);
    return CMD_OK;
  }

  /* You've got to be a master to 'silently' op other people */
  if (!cs_checkaccess(sender, NULL, CA_MASTERPRIV, cip, "op", 0, 1))
    donotice=1;

  /* Set up the modes */
  localsetmodeinit(&changes, cip->channel, chanservnick);

  for(i=1;i<cargc;i++) {
    if (!(np=getnickbynick(cargv[i]))) {
      chanservstdmessage(sender, QM_UNKNOWNUSER, cargv[i]);
      continue;
    }

    if (!(lp=getnumerichandlefromchanhash(cip->channel->users, np->numeric))) {
      chanservstdmessage(sender, QM_USERNOTONCHAN, np->nick, cip->name->content);
      continue;
    }

    if (*lp & CUMODE_OP) {
      chanservstdmessage(sender, QM_USEROPPEDONCHAN, np->nick, cip->name->content);
      continue;
    }

    rup=getreguserfromnick(np);
    if (rup)
      rcup=findreguseronchannel(rcp,rup);
    else
      rcup=NULL;

    /* Bitch mode: check that this user is allowed to be opped.. */
    if ((CIsBitch(rcp) && (!rcup || !CUHasOpPriv(rcup))) || (rcup && CUIsDeny(rcup))) {
      chanservstdmessage(sender, QM_CANTOP, np->nick, cip->name->content);
      continue;
    }

    bufpos += sprintf(buf+bufpos,"%s%s",bufpos?", ":"",np->nick);
    localdosetmode_nick(&changes, np, MC_OP);
  }

  if (donotice && bufpos) {
    sendopnoticetochannel(chanservnick, cip->channel, "%s opped %s", sender, buf);
  }
      
  localsetmodeflush(&changes, 1);
  chanservstdmessage(sender, QM_DONE);

  return CMD_OK;
}
