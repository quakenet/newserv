/* Automatically generated by refactor.pl.
 *
 *
 * CMDNAME: suspendchanlist
 * CMDLEVEL: QCMD_HELPER
 * CMDARGS: 1
 * CMDDESC: Lists suspended channels.
 * CMDFUNC: csc_dosuspendchanlist
 * CMDPROTO: int csc_dosuspendchanlist(void *source, int cargc, char **cargv);
 */

#include "../chanserv.h"
#include "../../nick/nick.h"
#include "../../lib/flags.h"
#include "../../lib/irc_string.h"
#include "../../channel/channel.h"
#include "../../parser/parser.h"
#include "../../irc/irc.h"
#include "../../localuser/localuserchannel.h"
#include <string.h>
#include <stdio.h>

int csc_dosuspendchanlist(void *source, int cargc, char **cargv) {
  nick *sender=source;
  reguser *rup=getreguserfromnick(sender);
  chanindex *cip;
  regchan *rcp;
  int i;
  char *bywhom;
  unsigned int count=0;
  
  if (!rup)
    return CMD_ERROR;
  
  if (cargc < 1) {
    chanservstdmessage(sender, QM_NOTENOUGHPARAMS, "suspendchanlist");
    return CMD_ERROR;
  }
  
  chanservstdmessage(sender, QM_SUSPENDCHANLISTHEADER);
  for (i=0; i<CHANNELHASHSIZE; i++) {
    for (cip=chantable[i]; cip; cip=cip->next) {
      if (!(rcp=(regchan*)cip->exts[chanservext]))
        continue;
      
      if (!CIsSuspended(rcp))
        continue;
      
      if ((rcp->suspendby != rup->ID) && match(cargv[0], cip->name->content))
        continue;
      
      if (rcp->suspendby == rup->ID)
        bywhom=rup->username;
      else {
        reguser *trup=findreguserbyID(rcp->suspendby);
        if (trup)
          bywhom=trup->username;
        else
          bywhom="unknown";
      }
      count++;
      chanservsendmessage(sender, "%-30s %-15s %s", cip->name->content, bywhom, rcp->suspendreason->content);
      if (count >= 2000) {
        chanservstdmessage(sender, QM_TOOMANYRESULTS, 2000, "channels");
        return CMD_ERROR;
      }
    }
  }
  chanservstdmessage(sender, QM_RESULTCOUNT, count, "channel", (count==1)?"":"s");
  
  return CMD_OK;
}
