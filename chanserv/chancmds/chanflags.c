/* Automatically generated by refactor.pl.
 *
 *
 * CMDNAME: chanflags
 * CMDLEVEL: QCMD_AUTHED
 * CMDARGS: 2
 * CMDDESC: Shows or changes the flags on a channel.
 * CMDFUNC: csc_dochanflags
 * CMDPROTO: int csc_dochanflags(void *source, int cargc, char **cargv);
 * CMDHELP: Usage: CHANFLAGS <channel> [<changes>]
 * CMDHELP: Shows or changes the status of channel flags, where:
 * CMDHELP: channel - channel to use
 * CMDHELP: changes - changes to apply to the channel flags in the usual +/- format, e.g. +c
 * CMDHELP:           to set +c and -c to remove it.
 * CMDHELP: Viewing the current flags requires operator (+o) access on the named channel.
 * CMDHELP: Changing the flags requires master (+m) access on the named channel.
 * CMDHELP: Valid channel flags are:
 * CMDHELP:  +a AUTOOP     Automatically ops any user who has op access when they join the
 * CMDHELP:                channel.  Same effect as giving all ops the +a chanlev flag.
 * CMDHELP:  +b BITCH      Prevents users who don't have operator access on the channel
 * CMDHELP:                from being opped (automatically deops them)
 * CMDHELP:  +c AUTOLIMIT  Enables automatic limit feature - updates the channel limit at
 * CMDHELP:                regular intervals to keep a certain number of free spaces.  This
 * CMDHELP:                can mitigate the effect of join floods.  See AUTOLIMIT.
 * CMDHELP:  +e ENFORCE    Enforces bans on the channel.  Any user who is banned will be
 * CMDHELP:                kicked automatically.
 * CMDHELP:  +f FORCETOPIC Prevents channel ops from changing the topic.  The SETTOPIC
 * CMDHELP:                command must be used instead.
 * CMDHELP:  +g AUTOVOICE  Automatically voices any user who has voice access when they join
 * CMDHELP:                the channel.  Same effect as giving all voices the +g chanlev flag.
 * CMDHELP:  +j JOINED     Causes Q to remain on the channel.  Cannot be removed.
 * CMDHELP:  +k KNOWNONLY  Any user who joins the channel who is not known (+k) will be kicked.  
 * CMDHELP:                Unless channel mode +i is set they will be banned as well.
 * CMDHELP:  +p PROTECT    Any user with voice (+v) or operator (+o) access will have that 
 * CMDHELP:                status enforced on the channel at all times.  Same effect as giving
 * CMDHELP:                all ops and voices the +p chanlev flag.
 * CMDHELP:  +t TOPICSAVE  Saves the topic when it changes.  Such saved topics can be restored
 * CMDHELP:                via settopic, or when the bot rejoins when a channel has been left
 * CMDHELP:                empty.
 * CMDHELP:  +v VOICEALL   Automatically grants voice (+v) on the channel to any user who enters,
 * CMDHELP:                unless they have quiet (+q) chanlev flag.
 * CMDHELP:  +w WELCOME    Sends the welcome message to users joining the channel.  See WELCOME.
 * CMDHELP: Note: Previous versions of Q included the facility to enforce limits and keys using
 * CMDHELP: +k and +l chanflags.  This functionality is now available via the CHANMODE command.
 */

#include "../chanserv.h"
#include "../../nick/nick.h"
#include "../../lib/flags.h"
#include "../../lib/irc_string.h"
#include "../../channel/channel.h"
#include "../../parser/parser.h"
#include "../../irc/irc.h"
#include "../../localuser/localuserchannel.h"
#include <string.h>
#include <stdio.h>

int csc_dochanflags(void *source, int cargc, char **cargv) {
  regchan *rcp;
  nick *sender=source;
  reguser *rup=getreguserfromnick(sender);
  chanindex *cip;
  flag_t oldflags,changemask;
  char flagbuf[20];

  if (cargc<1) {
    chanservstdmessage(sender,QM_NOTENOUGHPARAMS,"chanflags");
    return CMD_ERROR;
  }
  
  if (!(cip=cs_checkaccess(sender, cargv[0], CA_OPPRIV, NULL, 
			   "chanflags", QPRIV_VIEWCHANFLAGS, 0))) 
    return CMD_ERROR;

  rcp=cip->exts[chanservext];

  if (cargc>1) {
    if (!cs_checkaccess(sender, NULL, CA_MASTERPRIV, cip, "chanflags", 
			QPRIV_CHANGECHANFLAGS, 0))
      return CMD_ERROR;

    oldflags=rcp->flags;
    changemask=QCFLAG_USERCONTROL;
    if (UIsDev(rup)) {
      changemask=QCFLAG_ALL;
    }
    setflags(&rcp->flags, changemask, cargv[1], rcflags, REJECT_NONE);

    /* We might need to do things in response to the flag changes.. */
    if (cip->channel) {
      if ((oldflags ^ rcp->flags) & (QCFLAG_JOINED | QCFLAG_SUSPENDED)) {
        chanservjoinchan(cip->channel);
	rcp->status |= (QCSTAT_OPCHECK | QCSTAT_MODECHECK | QCSTAT_BANCHECK);
	rcp->lastbancheck=0;
	cs_timerfunc(cip);
      } else {
        if (CIsEnforce(rcp)) {
	  rcp->lastbancheck=0;
          cs_checkbans(cip->channel);  
	}
    
        if (CIsProtect(rcp) || CIsBitch(rcp) || CIsAutoOp(rcp) || CIsAutoVoice(rcp) || CIsKnownOnly(rcp)) {
	  rcp->status |= QCSTAT_OPCHECK;
	  cs_timerfunc(cip);
	}
      }
    }
    
    if (CIsAutoLimit(rcp) && !(oldflags & QCFLAG_AUTOLIMIT)) {
      rcp->forcemodes |= CHANMODE_LIMIT;
      rcp->denymodes &= ~CHANMODE_LIMIT;
      rcp->limit=0;
      cs_timerfunc(cip);
    }

    if (!CIsAutoLimit(rcp) && (oldflags & QCFLAG_AUTOLIMIT)) {
      rcp->forcemodes &= ~CHANMODE_LIMIT;
      if (cip->channel) 
        cs_checkchanmodes(cip->channel);
    }

    /* If nothing has changed, say so and don't do anything else */
    if (rcp->flags == oldflags) {
      chanservstdmessage(sender, QM_CHANLEVNOCHANGE);
      return CMD_OK;
    }
    
    strcpy(flagbuf,printflags(oldflags, rcflags));
    cs_log(sender,"CHANFLAGS %s %s (%s -> %s)",cip->name->content,cargv[1],flagbuf,printflags(rcp->flags,rcflags));
    chanservstdmessage(sender, QM_DONE);
    csdb_updatechannel(rcp);
  }
  
  chanservstdmessage(sender,QM_CURCHANFLAGS,cip->name->content,printflags(rcp->flags, rcflags));
  return CMD_OK;
}
