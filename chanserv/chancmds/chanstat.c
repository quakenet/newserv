/* Automatically generated by refactor.pl.
 *
 *
 * CMDNAME: chanstat
 * CMDLEVEL: QCMD_AUTHED
 * CMDARGS: 2
 * CMDDESC: Displays channel activity statistics.
 * CMDFUNC: csc_dochanstat
 * CMDPROTO: int csc_dochanstat(void *source, int cargc, char **cargv);
 * CMDHELP: Usage: CHANSTAT <channel> [RESET]
 * CMDHELP: Shows some statistics about a channel, including total number of joins and 
 * CMDHELP: maximum channel size.  Two sets of statistics are displayed, a lifetime
 * CMDHELP: counter, and a trip meter counter which can be reset.  Where:
 * CMDHELP: channel - channel to display statistics for.
 * CMDHELP: CHANSTAT requires master (+m) access on the named channel.
 */

#include "../chanserv.h"
#include "../../nick/nick.h"
#include "../../lib/flags.h"
#include "../../lib/irc_string.h"
#include "../../channel/channel.h"
#include "../../parser/parser.h"
#include "../../irc/irc.h"
#include "../../localuser/localuserchannel.h"
#include <string.h>
#include <stdio.h>

int csc_dochanstat(void *source, int cargc, char **cargv) {
  nick *sender=source;
  chanindex *cip;
  regchan *rcp;
  
  if (cargc<1) {
    chanservstdmessage(sender, QM_NOTENOUGHPARAMS, "chanstat");
    return CMD_ERROR;
  }

  if (!(cip=cs_checkaccess(sender, cargv[0], CA_MASTERPRIV,
			   NULL, "chanstat", QPRIV_VIEWFULLCHANLEV, 0)))
    return CMD_ERROR;
  
  rcp=cip->exts[chanservext];

  chanservstdmessage(sender, QM_STATSHEADER, cip->name->content);

  chanservstdmessage(sender, QM_STATSADDED, rcp->created);

  /* Show opers founder/addedby/type info */
  if (cs_privcheck(QPRIV_VIEWFULLCHANLEV, sender)) {
    reguser *founder=NULL, *addedby=NULL;

    chanservstdmessage(sender, QM_STATSLASTACTIVE, rcp->lastactive);

    addedby=findreguserbyID(rcp->addedby);
    chanservstdmessage(sender, QM_ADDEDBY, addedby ? addedby->username : "(unknown)");
    founder=findreguserbyID(rcp->founder);
    chanservstdmessage(sender, QM_FOUNDER, founder ? founder->username : "(unknown)");      
    chanservstdmessage(sender, QM_CHANTYPE, chantypes[rcp->chantype]->content);
  }

  chanservstdmessage(sender, QM_STATSJOINS, rcp->created, rcp->maxusers, rcp->totaljoins, 
		     (float)rcp->totaljoins/ ((time(NULL)-rcp->created)/(3600*24)));

  chanservstdmessage(sender, QM_STATSJOINS, rcp->statsreset, rcp->tripusers, rcp->tripjoins, 
		     (float)rcp->tripjoins / ((time(NULL)-rcp->statsreset)/(3600*24)));
  
  if (cargc>1 && !ircd_strcmp(cargv[1],"reset")) {
    if (!(cip=cs_checkaccess(sender, cargv[0], CA_MASTERPRIV,
			     NULL, "chanstat", QPRIV_RESETCHANSTAT, 0)))
      return CMD_ERROR;

    rcp->statsreset=time(NULL);
    rcp->tripusers=0;
    rcp->tripjoins=0;
    chanservstdmessage(sender, QM_STATSRESET, cip->name->content);
    csdb_updatechannel(rcp);
  }

  return CMD_OK;
}
