/* Automatically generated by refactor.pl.
 *
 *
 * CMDNAME: lastreg
 * CMDLEVEL: QCMD_OPER
 * CMDARGS: 1
 * CMDDESC: List last N registered accounts
 * CMDFUNC: csa_dolastreg
 * CMDPROTO: int csa_dolastreg(void *source, int cargc, char **cargv);
 * CMDHELP: Usage: lastreg [N]
 * CMDHELP: Shows list of most recently registered accounts
 */

#include "../chanserv.h"
#include "../../lib/irc_string.h"
#include "../../dbapi/dbapi.h"

#include <stdio.h>
#include <string.h>

/* This file is basically a copy of accounthistory.c, with adaptations of course */

void csdb_dolastreg_real(DBConn *dbconn, void *arg) {
  nick *np=getnickbynumeric((unsigned long)arg);
  reguser *rup;
  char *username;
  time_t created, lastauth, suspendtime;
  DBResult *pgres;
  char tbuf[TIMELEN];
  char tbuf2[TIMELEN];
  char *suspended;
  unsigned int userID;

  if(!dbconn)
    return;

  pgres=dbgetresult(dbconn);

  if (!dbquerysuccessful(pgres)) {
    Error("chanserv", ERR_ERROR, "Error loading lastreg data.");
    return;
  }

  if (dbnumfields(pgres) != 5) {
    Error("chanserv", ERR_ERROR, "lastreg data format error.");
    dbclear(pgres);
    return;
  }

  if (!np) {
    dbclear(pgres);
    return;
  }

  if (!(rup=getreguserfromnick(np)) || !UHasOperPriv(rup)) {
    Error("chanserv", ERR_ERROR, "No reguser pointer or oper privs in lastreg.");
    dbclear(pgres);
    return;
  }

  chanservsendmessage(np, "%-9s %-19s %-18s %-19s", "ID:", "Created TS:", "Username:", "Last auth TS:");
  while(dbfetchrow(pgres)) {
    userID=strtoul(dbgetvalue(pgres, 0), NULL, 10);
    username=dbgetvalue(pgres, 1);
    created=strtoul(dbgetvalue(pgres, 2), NULL, 10);
    lastauth=strtoul(dbgetvalue(pgres, 3), NULL, 10);
    suspendtime=strtoul(dbgetvalue(pgres, 4), NULL, 10);
    q9strftime(tbuf, sizeof(tbuf), created);
    if (lastauth > 0)
      q9strftime(tbuf2, sizeof(tbuf2), lastauth);
    else
      strcpy(tbuf2, "-");
    suspended = (suspendtime > 0) ? "   (Suspended)" : "";
    chanservsendmessage(np, "%-9u %-19s %-18s %-19s%s", userID, tbuf, username, tbuf2, suspended);
  }
  chanservstdmessage(np, QM_ENDOFLIST);

  dbclear(pgres);
}

void csdb_retreivelastreg(nick *np, int limit) {
  q9u_asyncquery(csdb_dolastreg_real, (void *)np->numeric,
    "SELECT ID, username, created, lastauth, suspendtime from chanserv.users ORDER BY ID DESC LIMIT %d", limit);
}

int csa_dolastreg(void *source, int cargc, char **cargv) {
  reguser *rup;
  nick *sender=source;
  char *endptr;
  long limit=10;
  
  if (!(rup=getreguserfromnick(sender)))
    return CMD_ERROR;

  if (!UHasAdminPriv(rup)) {
    chanservstdmessage(sender, QM_NOACCESS, "lastreg", cargv[0]);
    return CMD_ERROR;
  }

  if (cargc > 0) {
    limit=strtol(cargv[0], &endptr, 10);
    if ((cargv[0] == endptr) || (*endptr != '\0')) {
      limit=10;
      chanservsendmessage(sender, "Value '%s' is not a valid value. Using default: %ld", cargv[0], limit);
    }
    else if (limit > 100) {
      limit=100;
      chanservsendmessage(sender, "Value '%s' is too high. Maximum is 100.", cargv[0]);
    }
  }

  csdb_retreivelastreg(sender, limit);
  return CMD_OK;
}
